{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst {\n  EventEmitter\n} = require(\"events\");\n\nconst {\n  URL\n} = require(\"whatwg-url\");\n\nconst parseDataURL = require(\"data-urls\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst agentFactory = require(\"../helpers/agent-factory\");\n\nconst Request = require(\"../helpers/http-request\");\n\nconst FormData = require(\"form-data\");\n\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\"access-control-expose-headers\", \"access-control-allow-headers\", \"access-control-allow-credentials\", \"access-control-allow-origin\"]);\nconst READY_STATES = exports.READY_STATES = Object.freeze({\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n});\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr.properties.error;\n  requestErrorSteps(xhr, \"error\", DOMException.create(xhr._globalObject, [errMessage, \"NetworkError\"]));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = acah.has(\"*\") ? [] : Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const {\n    flag,\n    properties,\n    upload\n  } = xhr;\n  xhr.readyState = READY_STATES.DONE;\n  properties.send = false;\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n      fireAnEvent(\"loadend\", upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const {\n    properties\n  } = xhr;\n  properties.responseBuffer = properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  xhr.status = 0;\n  xhr.statusText = \"\";\n} // return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\n\n\nfunction createClient(xhr) {\n  const {\n    flag,\n    properties\n  } = xhr;\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n  const {\n    requestManager\n  } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    const filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n    const client = new EventEmitter();\n    const readableStream = fs.createReadStream(filePath, {\n      encoding: null\n    });\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response, urlObj.href));\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n    const client = new EventEmitter();\n    let buffer;\n\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = {\n        \"content-type\": contentType\n      };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {// do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response, urlObj.href);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n    return client;\n  }\n\n  const agents = agentFactory(flag.proxy, flag.strictSSL);\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    rejectUnauthorized: flag.strictSSL,\n    agents,\n    followRedirects: true\n  };\n\n  if (flag.auth) {\n    options.user = flag.auth.user || \"\";\n    options.pass = flag.auth.pass || \"\";\n  }\n\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.cookieJar = flag.cookieJar;\n  }\n\n  const {\n    body\n  } = flag;\n  const hasBody = body !== undefined && body !== null && body !== \"\" && !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      let requestBody = body;\n      let len = 0;\n\n      if (hasBody) {\n        if (flag.formData) {\n          // TODO: implement https://html.spec.whatwg.org/#multipart-form-data\n          // directly instead of using an external library\n          requestBody = new FormData();\n\n          for (const entry of body) {\n            requestBody.append(entry.name, entry.value, entry.options);\n          }\n\n          len = requestBody.getLengthSync();\n          requestHeaders[\"Content-Type\"] = `multipart/form-data; boundary=${requestBody.getBoundary()}`;\n        } else {\n          if (typeof body === \"string\") {\n            len = Buffer.byteLength(body);\n          } else {\n            len = body.length;\n          }\n\n          requestBody = Buffer.isBuffer(requestBody) ? requestBody : Buffer.from(requestBody);\n        }\n\n        requestHeaders[\"Content-Length\"] = len;\n      }\n\n      requestHeaders[\"Accept-Encoding\"] = \"gzip, deflate\";\n      const requestClient = new Request(uri, options, {\n        method: flag.method,\n        headers: requestHeaders\n      });\n\n      if (hasBody) {\n        if (flag.formData) {\n          requestBody.on(\"error\", err => {\n            requestClient.emit(\"error\", err);\n            requestClient.abort();\n          });\n          requestClient.pipeRequest(requestBody);\n        } else {\n          requestClient.write(requestBody);\n        }\n      }\n\n      return requestClient;\n    } catch (e) {\n      const eventEmitterclient = new EventEmitter();\n      process.nextTick(() => eventEmitterclient.emit(\"error\", e));\n\n      eventEmitterclient.end = () => {};\n\n      return eventEmitterclient;\n    }\n  }\n\n  let client;\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n    const preflightRequestHeaders = {};\n\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referer\n      const lcHeader = header.toLowerCase();\n\n      if (lcHeader === \"origin\" || lcHeader === \"referer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n    flag.preflight = true;\n    const rejectUnauthorized = flag.strictSSL;\n    const preflightClient = new Request(uri, {\n      agents,\n      followRedirects: false\n    }, {\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      rejectUnauthorized\n    });\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      } // don't send the real request if we aren't allowed to use the headers\n\n\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      } // Set request gzip option right before headers are set\n\n\n      const realClient = doRequest();\n      realClient.on(\"response\", function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return client.emit(\"response\", ...args);\n      });\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        client.emit(\"redirect\", ...args);\n      });\n      realClient.on(\"error\", err => {\n        client.emit(\"error\", err);\n      });\n\n      client.abort = () => {\n        realClient.abort();\n      };\n\n      setImmediate(() => realClient.end());\n    });\n    preflightClient.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n\n    setImmediate(() => preflightClient.end());\n  } else {\n    client = doRequest();\n    setImmediate(() => client.end());\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;","map":{"version":3,"sources":["/Applications/MAMP/htdocs/aljazira/node_modules/jsdom/lib/jsdom/living/xhr/xhr-utils.js"],"names":["fs","require","EventEmitter","URL","parseDataURL","DOMException","ProgressEvent","agentFactory","Request","FormData","fireAnEvent","headerListSeparatorRegexp","simpleMethods","Set","simpleHeaders","preflightHeaders","READY_STATES","exports","Object","freeze","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","getRequestHeader","requestHeaders","header","lcHeader","toLowerCase","keys","n","length","key","updateRequestHeader","newValue","dispatchError","xhr","errMessage","properties","error","requestErrorSteps","create","_globalObject","_ownerDocument","Error","type","_defaultView","_virtualConsole","emit","validCORSHeaders","response","flag","origin","acaoStr","headers","acao","trim","acacStr","acac","withCredentials","validCORSPreflightHeaders","acahStr","acah","split","forbiddenHeaders","has","filter","event","exception","upload","readyState","send","setResponseToNetworkError","synchronous","uploadComplete","uploadListener","loaded","total","lengthComputable","responseBuffer","responseCache","responseTextCache","responseXMLCache","responseHeaders","status","statusText","createClient","urlObj","uri","href","ucMethod","method","toUpperCase","requestManager","protocol","statusCode","rawHeaders","filePath","pathname","replace","client","readableStream","createReadStream","encoding","on","chunk","err","abort","destroy","req","abortError","add","rmReq","remove","bind","process","nextTick","buffer","parsed","contentType","mimeType","toString","body","agents","proxy","strictSSL","Referer","referrer","userAgent","Accept","crossOrigin","Origin","options","rejectUnauthorized","followRedirects","auth","user","pass","cookieJar","hasBody","undefined","doRequest","requestBody","len","formData","entry","append","name","value","getLengthSync","getBoundary","Buffer","byteLength","isBuffer","from","requestClient","pipeRequest","write","e","eventEmitterclient","end","nonSimpleHeaders","preflightRequestHeaders","join","preflight","preflightClient","resp","realClient","args","setImmediate"],"mappings":"AAAA;;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAmBD,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAUF,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,WAAD,CAA5B;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,gCAAD,CAA5B;;AAEA,MAAMK,aAAa,GAAGL,OAAO,CAAC,4BAAD,CAA7B;;AAEA,MAAMM,YAAY,GAAGN,OAAO,CAAC,0BAAD,CAA5B;;AACA,MAAMO,OAAO,GAAGP,OAAO,CAAC,yBAAD,CAAvB;;AACA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAM;AAAES,EAAAA;AAAF,IAAkBT,OAAO,CAAC,mBAAD,CAA/B;;AAEA,MAAMU,yBAAyB,GAAG,SAAlC;AACA,MAAMC,aAAa,GAAG,IAAIC,GAAJ,CAAQ,CAAC,KAAD,EAAQ,MAAR,EAAgB,MAAhB,CAAR,CAAtB;AACA,MAAMC,aAAa,GAAG,IAAID,GAAJ,CAAQ,CAAC,QAAD,EAAW,iBAAX,EAA8B,kBAA9B,EAAkD,cAAlD,CAAR,CAAtB;AACA,MAAME,gBAAgB,GAAG,IAAIF,GAAJ,CAAQ,CAC/B,+BAD+B,EAE/B,8BAF+B,EAG/B,kCAH+B,EAI/B,6BAJ+B,CAAR,CAAzB;AAOA,MAAMG,YAAY,GAAGC,OAAO,CAACD,YAAR,GAAuBE,MAAM,CAACC,MAAP,CAAc;AACxDC,EAAAA,MAAM,EAAE,CADgD;AAExDC,EAAAA,MAAM,EAAE,CAFgD;AAGxDC,EAAAA,gBAAgB,EAAE,CAHsC;AAIxDC,EAAAA,OAAO,EAAE,CAJ+C;AAKxDC,EAAAA,IAAI,EAAE;AALkD,CAAd,CAA5C;;AAQA,SAASC,gBAAT,CAA0BC,cAA1B,EAA0CC,MAA1C,EAAkD;AAChD,QAAMC,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;AACA,QAAMC,IAAI,GAAGZ,MAAM,CAACY,IAAP,CAAYJ,cAAZ,CAAb;AACA,MAAIK,CAAC,GAAGD,IAAI,CAACE,MAAb;;AACA,SAAOD,CAAC,EAAR,EAAY;AACV,UAAME,GAAG,GAAGH,IAAI,CAACC,CAAD,CAAhB;;AACA,QAAIE,GAAG,CAACJ,WAAJ,OAAsBD,QAA1B,EAAoC;AAClC,aAAOF,cAAc,CAACO,GAAD,CAArB;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAASC,mBAAT,CAA6BR,cAA7B,EAA6CC,MAA7C,EAAqDQ,QAArD,EAA+D;AAC7D,QAAMP,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;AACA,QAAMC,IAAI,GAAGZ,MAAM,CAACY,IAAP,CAAYJ,cAAZ,CAAb;AACA,MAAIK,CAAC,GAAGD,IAAI,CAACE,MAAb;;AACA,SAAOD,CAAC,EAAR,EAAY;AACV,UAAME,GAAG,GAAGH,IAAI,CAACC,CAAD,CAAhB;;AACA,QAAIE,GAAG,CAACJ,WAAJ,OAAsBD,QAA1B,EAAoC;AAClCF,MAAAA,cAAc,CAACO,GAAD,CAAd,GAAsBE,QAAtB;AACD;AACF;AACF;;AAED,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;AAC1B,QAAMC,UAAU,GAAGD,GAAG,CAACE,UAAJ,CAAeC,KAAlC;AACAC,EAAAA,iBAAiB,CAACJ,GAAD,EAAM,OAAN,EAAehC,YAAY,CAACqC,MAAb,CAAoBL,GAAG,CAACM,aAAxB,EAAuC,CAACL,UAAD,EAAa,cAAb,CAAvC,CAAf,CAAjB;;AAEA,MAAID,GAAG,CAACO,cAAR,EAAwB;AACtB,UAAMJ,KAAK,GAAG,IAAIK,KAAJ,CAAUP,UAAV,CAAd;AACAE,IAAAA,KAAK,CAACM,IAAN,GAAa,gBAAb,CAFsB,CAES;;AAE/BT,IAAAA,GAAG,CAACO,cAAJ,CAAmBG,YAAnB,CAAgCC,eAAhC,CAAgDC,IAAhD,CAAqD,YAArD,EAAmET,KAAnE;AACD;AACF;;AAED,SAASU,gBAAT,CAA0Bb,GAA1B,EAA+Bc,QAA/B,EAAyCC,IAAzC,EAA+Cb,UAA/C,EAA2Dc,MAA3D,EAAmE;AACjE,QAAMC,OAAO,GAAGH,QAAQ,CAACI,OAAT,CAAiB,6BAAjB,CAAhB;AACA,QAAMC,IAAI,GAAGF,OAAO,GAAGA,OAAO,CAACG,IAAR,EAAH,GAAoB,IAAxC;;AACA,MAAID,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAKH,MAA7B,EAAqC;AACnCd,IAAAA,UAAU,CAACC,KAAX,GAAmB,kBAAkBa,MAAlB,GAA2B,YAA9C;AACAjB,IAAAA,aAAa,CAACC,GAAD,CAAb;AACA,WAAO,KAAP;AACD;;AACD,QAAMqB,OAAO,GAAGP,QAAQ,CAACI,OAAT,CAAiB,kCAAjB,CAAhB;AACA,QAAMI,IAAI,GAAGD,OAAO,GAAGA,OAAO,CAACD,IAAR,EAAH,GAAoB,IAAxC;;AACA,MAAIL,IAAI,CAACQ,eAAL,IAAwBD,IAAI,KAAK,MAArC,EAA6C;AAC3CpB,IAAAA,UAAU,CAACC,KAAX,GAAmB,uBAAnB;AACAJ,IAAAA,aAAa,CAACC,GAAD,CAAb;AACA,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASwB,yBAAT,CAAmCxB,GAAnC,EAAwCc,QAAxC,EAAkDC,IAAlD,EAAwDb,UAAxD,EAAoE;AAClE,MAAI,CAACW,gBAAgB,CAACb,GAAD,EAAMc,QAAN,EAAgBC,IAAhB,EAAsBb,UAAtB,EAAkCA,UAAU,CAACc,MAA7C,CAArB,EAA2E;AACzE,WAAO,KAAP;AACD;;AACD,QAAMS,OAAO,GAAGX,QAAQ,CAACI,OAAT,CAAiB,8BAAjB,CAAhB;AACA,QAAMQ,IAAI,GAAG,IAAIlD,GAAJ,CAAQiD,OAAO,GAAGA,OAAO,CAACL,IAAR,GAAe5B,WAAf,GAA6BmC,KAA7B,CAAmCrD,yBAAnC,CAAH,GAAmE,EAAlF,CAAb;AACA,QAAMsD,gBAAgB,GAAGF,IAAI,CAACG,GAAL,CAAS,GAAT,IACzB,EADyB,GAEzBhD,MAAM,CAACY,IAAP,CAAYsB,IAAI,CAAC1B,cAAjB,EAAiCyC,MAAjC,CAAwCxC,MAAM,IAAI;AAChD,UAAMC,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;AACA,WAAO,CAACf,aAAa,CAACoD,GAAd,CAAkBtC,QAAlB,CAAD,IAAgC,CAACmC,IAAI,CAACG,GAAL,CAAStC,QAAT,CAAxC;AACD,GAHD,CAFA;;AAMA,MAAIqC,gBAAgB,CAACjC,MAAjB,GAA0B,CAA9B,EAAiC;AAC/BO,IAAAA,UAAU,CAACC,KAAX,GAAmB,aAAayB,gBAAb,GAAgC,YAAnD;AACA7B,IAAAA,aAAa,CAACC,GAAD,CAAb;AACA,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASI,iBAAT,CAA2BJ,GAA3B,EAAgC+B,KAAhC,EAAuCC,SAAvC,EAAkD;AAChD,QAAM;AAAEjB,IAAAA,IAAF;AAAQb,IAAAA,UAAR;AAAoB+B,IAAAA;AAApB,MAA+BjC,GAArC;AAEAA,EAAAA,GAAG,CAACkC,UAAJ,GAAiBvD,YAAY,CAACQ,IAA9B;AACAe,EAAAA,UAAU,CAACiC,IAAX,GAAkB,KAAlB;AAEAC,EAAAA,yBAAyB,CAACpC,GAAD,CAAzB;;AAEA,MAAIe,IAAI,CAACsB,WAAT,EAAsB;AACpB,UAAML,SAAN;AACD;;AAED3D,EAAAA,WAAW,CAAC,kBAAD,EAAqB2B,GAArB,CAAX;;AAEA,MAAI,CAACE,UAAU,CAACoC,cAAhB,EAAgC;AAC9BpC,IAAAA,UAAU,CAACoC,cAAX,GAA4B,IAA5B;;AAEA,QAAIpC,UAAU,CAACqC,cAAf,EAA+B;AAC7BlE,MAAAA,WAAW,CAAC0D,KAAD,EAAQE,MAAR,EAAgBhE,aAAhB,EAA+B;AAAEuE,QAAAA,MAAM,EAAE,CAAV;AAAaC,QAAAA,KAAK,EAAE,CAApB;AAAuBC,QAAAA,gBAAgB,EAAE;AAAzC,OAA/B,CAAX;AACArE,MAAAA,WAAW,CAAC,SAAD,EAAY4D,MAAZ,EAAoBhE,aAApB,EAAmC;AAAEuE,QAAAA,MAAM,EAAE,CAAV;AAAaC,QAAAA,KAAK,EAAE,CAApB;AAAuBC,QAAAA,gBAAgB,EAAE;AAAzC,OAAnC,CAAX;AACD;AACF;;AAEDrE,EAAAA,WAAW,CAAC0D,KAAD,EAAQ/B,GAAR,EAAa/B,aAAb,EAA4B;AAAEuE,IAAAA,MAAM,EAAE,CAAV;AAAaC,IAAAA,KAAK,EAAE,CAApB;AAAuBC,IAAAA,gBAAgB,EAAE;AAAzC,GAA5B,CAAX;AACArE,EAAAA,WAAW,CAAC,SAAD,EAAY2B,GAAZ,EAAiB/B,aAAjB,EAAgC;AAAEuE,IAAAA,MAAM,EAAE,CAAV;AAAaC,IAAAA,KAAK,EAAE,CAApB;AAAuBC,IAAAA,gBAAgB,EAAE;AAAzC,GAAhC,CAAX;AACD;;AAED,SAASN,yBAAT,CAAmCpC,GAAnC,EAAwC;AACtC,QAAM;AAAEE,IAAAA;AAAF,MAAiBF,GAAvB;AAEAE,EAAAA,UAAU,CAACyC,cAAX,GACEzC,UAAU,CAAC0C,aAAX,GACA1C,UAAU,CAAC2C,iBAAX,GACA3C,UAAU,CAAC4C,gBAAX,GAA8B,IAHhC;AAKA5C,EAAAA,UAAU,CAAC6C,eAAX,GAA6B,EAA7B;AACA/C,EAAAA,GAAG,CAACgD,MAAJ,GAAa,CAAb;AACAhD,EAAAA,GAAG,CAACiD,UAAJ,GAAiB,EAAjB;AACD,C,CAED;AACA;;;AACA,SAASC,YAAT,CAAsBlD,GAAtB,EAA2B;AACzB,QAAM;AAAEe,IAAAA,IAAF;AAAQb,IAAAA;AAAR,MAAuBF,GAA7B;AACA,QAAMmD,MAAM,GAAG,IAAIrF,GAAJ,CAAQiD,IAAI,CAACqC,GAAb,CAAf;AACA,QAAMA,GAAG,GAAGD,MAAM,CAACE,IAAnB;AACA,QAAMC,QAAQ,GAAGvC,IAAI,CAACwC,MAAL,CAAYC,WAAZ,EAAjB;AAEA,QAAM;AAAEC,IAAAA;AAAF,MAAqB1C,IAA3B;;AAEA,MAAIoC,MAAM,CAACO,QAAP,KAAoB,OAAxB,EAAiC;AAC/B,UAAM5C,QAAQ,GAAG,IAAIjD,YAAJ,EAAjB;AACAiD,IAAAA,QAAQ,CAAC6C,UAAT,GAAsB,GAAtB;AACA7C,IAAAA,QAAQ,CAAC8C,UAAT,GAAsB,EAAtB;AACA9C,IAAAA,QAAQ,CAACI,OAAT,GAAmB,EAAnB;AACA,UAAM2C,QAAQ,GAAGV,MAAM,CAACW,QAAP,CACdC,OADc,CACN,YADM,EACQ,EADR,EAEdA,OAFc,CAEN,gBAFM,EAEY,MAFZ,EAGdA,OAHc,CAGN,MAHM,EAGE,GAHF,CAAjB;AAKA,UAAMC,MAAM,GAAG,IAAInG,YAAJ,EAAf;AAEA,UAAMoG,cAAc,GAAGtG,EAAE,CAACuG,gBAAH,CAAoBL,QAApB,EAA8B;AAAEM,MAAAA,QAAQ,EAAE;AAAZ,KAA9B,CAAvB;AAEAF,IAAAA,cAAc,CAACG,EAAf,CAAkB,MAAlB,EAA0BC,KAAK,IAAI;AACjCvD,MAAAA,QAAQ,CAACF,IAAT,CAAc,MAAd,EAAsByD,KAAtB;AACAL,MAAAA,MAAM,CAACpD,IAAP,CAAY,MAAZ,EAAoByD,KAApB;AACD,KAHD;AAKAJ,IAAAA,cAAc,CAACG,EAAf,CAAkB,KAAlB,EAAyB,MAAM;AAC7BtD,MAAAA,QAAQ,CAACF,IAAT,CAAc,KAAd;AACAoD,MAAAA,MAAM,CAACpD,IAAP,CAAY,KAAZ;AACD,KAHD;AAKAqD,IAAAA,cAAc,CAACG,EAAf,CAAkB,OAAlB,EAA2BE,GAAG,IAAI;AAChCN,MAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB;AACD,KAFD;;AAIAN,IAAAA,MAAM,CAACO,KAAP,GAAe,YAAY;AACzBN,MAAAA,cAAc,CAACO,OAAf;AACAR,MAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ;AACD,KAHD;;AAKA,QAAI6C,cAAJ,EAAoB;AAClB,YAAMgB,GAAG,GAAG;AACVF,QAAAA,KAAK,GAAG;AACNrE,UAAAA,UAAU,CAACwE,UAAX,GAAwB,IAAxB;AACA1E,UAAAA,GAAG,CAACuE,KAAJ;AACD;;AAJS,OAAZ;AAMAd,MAAAA,cAAc,CAACkB,GAAf,CAAmBF,GAAnB;AACA,YAAMG,KAAK,GAAGnB,cAAc,CAACoB,MAAf,CAAsBC,IAAtB,CAA2BrB,cAA3B,EAA2CgB,GAA3C,CAAd;AACAT,MAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,MAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,MAAAA,MAAM,CAACI,EAAP,CAAU,KAAV,EAAiBQ,KAAjB;AACD;;AAEDG,IAAAA,OAAO,CAACC,QAAR,CAAiB,MAAMhB,MAAM,CAACpD,IAAP,CAAY,UAAZ,EAAwBE,QAAxB,EAAkCqC,MAAM,CAACE,IAAzC,CAAvB;AAEA,WAAOW,MAAP;AACD;;AAED,MAAIb,MAAM,CAACO,QAAP,KAAoB,OAAxB,EAAiC;AAC/B,UAAM5C,QAAQ,GAAG,IAAIjD,YAAJ,EAAjB;AAEA,UAAMmG,MAAM,GAAG,IAAInG,YAAJ,EAAf;AAEA,QAAIoH,MAAJ;;AACA,QAAI;AACF,YAAMC,MAAM,GAAGnH,YAAY,CAACqF,GAAD,CAA3B;AACA,YAAM+B,WAAW,GAAGD,MAAM,CAACE,QAAP,CAAgBC,QAAhB,EAApB;AACAJ,MAAAA,MAAM,GAAGC,MAAM,CAACI,IAAhB;AACAxE,MAAAA,QAAQ,CAAC6C,UAAT,GAAsB,GAAtB;AACA7C,MAAAA,QAAQ,CAAC8C,UAAT,GAAsB,CAAC,cAAD,EAAiBuB,WAAjB,CAAtB;AACArE,MAAAA,QAAQ,CAACI,OAAT,GAAmB;AAAE,wBAAgBiE;AAAlB,OAAnB;AACD,KAPD,CAOE,OAAOb,GAAP,EAAY;AACZS,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAMhB,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB,CAAvB;AACA,aAAON,MAAP;AACD;;AAEDA,IAAAA,MAAM,CAACO,KAAP,GAAe,MAAM,CACnB;AACD,KAFD;;AAIAQ,IAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACrBhB,MAAAA,MAAM,CAACpD,IAAP,CAAY,UAAZ,EAAwBE,QAAxB,EAAkCqC,MAAM,CAACE,IAAzC;AACA0B,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACrBlE,QAAAA,QAAQ,CAACF,IAAT,CAAc,MAAd,EAAsBqE,MAAtB;AACAjB,QAAAA,MAAM,CAACpD,IAAP,CAAY,MAAZ,EAAoBqE,MAApB;AACAnE,QAAAA,QAAQ,CAACF,IAAT,CAAc,KAAd;AACAoD,QAAAA,MAAM,CAACpD,IAAP,CAAY,KAAZ;AACD,OALD;AAMD,KARD;AAUA,WAAOoD,MAAP;AACD;;AACD,QAAMuB,MAAM,GAAGrH,YAAY,CAAC6C,IAAI,CAACyE,KAAN,EAAazE,IAAI,CAAC0E,SAAlB,CAA3B;AACA,QAAMpG,cAAc,GAAG,EAAvB;;AAEA,OAAK,MAAMC,MAAX,IAAqByB,IAAI,CAAC1B,cAA1B,EAA0C;AACxCA,IAAAA,cAAc,CAACC,MAAD,CAAd,GAAyByB,IAAI,CAAC1B,cAAL,CAAoBC,MAApB,CAAzB;AACD;;AAED,MAAIF,gBAAgB,CAAC2B,IAAI,CAAC1B,cAAN,EAAsB,SAAtB,CAAhB,KAAqD,IAAzD,EAA+D;AAC7DA,IAAAA,cAAc,CAACqG,OAAf,GAAyB3E,IAAI,CAAC4E,QAA9B;AACD;;AACD,MAAIvG,gBAAgB,CAAC2B,IAAI,CAAC1B,cAAN,EAAsB,YAAtB,CAAhB,KAAwD,IAA5D,EAAkE;AAChEA,IAAAA,cAAc,CAAC,YAAD,CAAd,GAA+B0B,IAAI,CAAC6E,SAApC;AACD;;AACD,MAAIxG,gBAAgB,CAAC2B,IAAI,CAAC1B,cAAN,EAAsB,iBAAtB,CAAhB,KAA6D,IAAjE,EAAuE;AACrEA,IAAAA,cAAc,CAAC,iBAAD,CAAd,GAAoC,IAApC;AACD;;AACD,MAAID,gBAAgB,CAAC2B,IAAI,CAAC1B,cAAN,EAAsB,QAAtB,CAAhB,KAAoD,IAAxD,EAA8D;AAC5DA,IAAAA,cAAc,CAACwG,MAAf,GAAwB,KAAxB;AACD;;AAED,QAAMC,WAAW,GAAG/E,IAAI,CAACC,MAAL,KAAgBmC,MAAM,CAACnC,MAA3C;;AACA,MAAI8E,WAAJ,EAAiB;AACfzG,IAAAA,cAAc,CAAC0G,MAAf,GAAwBhF,IAAI,CAACC,MAA7B;AACD;;AAED,QAAMgF,OAAO,GAAG;AAAEC,IAAAA,kBAAkB,EAAElF,IAAI,CAAC0E,SAA3B;AAAsCF,IAAAA,MAAtC;AAA8CW,IAAAA,eAAe,EAAE;AAA/D,GAAhB;;AACA,MAAInF,IAAI,CAACoF,IAAT,EAAe;AACbH,IAAAA,OAAO,CAACI,IAAR,GAAerF,IAAI,CAACoF,IAAL,CAAUC,IAAV,IAAkB,EAAjC;AACAJ,IAAAA,OAAO,CAACK,IAAR,GAAetF,IAAI,CAACoF,IAAL,CAAUE,IAAV,IAAkB,EAAjC;AACD;;AACD,MAAItF,IAAI,CAACuF,SAAL,KAAmB,CAACR,WAAD,IAAgB/E,IAAI,CAACQ,eAAxC,CAAJ,EAA8D;AAC5DyE,IAAAA,OAAO,CAACM,SAAR,GAAoBvF,IAAI,CAACuF,SAAzB;AACD;;AAED,QAAM;AAAEhB,IAAAA;AAAF,MAAWvE,IAAjB;AACA,QAAMwF,OAAO,GAAGjB,IAAI,KAAKkB,SAAT,IACAlB,IAAI,KAAK,IADT,IAEAA,IAAI,KAAK,EAFT,IAGA,EAAEhC,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,KAAtC,CAHhB;;AAKA,MAAIiD,OAAO,IAAInH,gBAAgB,CAAC2B,IAAI,CAAC1B,cAAN,EAAsB,cAAtB,CAAhB,KAA0D,IAAzE,EAA+E;AAC7EA,IAAAA,cAAc,CAAC,cAAD,CAAd,GAAiC,0BAAjC;AACD;;AAED,WAASoH,SAAT,GAAqB;AACnB,QAAI;AACF,UAAIC,WAAW,GAAGpB,IAAlB;AACA,UAAIqB,GAAG,GAAG,CAAV;;AACA,UAAIJ,OAAJ,EAAa;AACX,YAAIxF,IAAI,CAAC6F,QAAT,EAAmB;AACjB;AACA;AACAF,UAAAA,WAAW,GAAG,IAAItI,QAAJ,EAAd;;AACA,eAAK,MAAMyI,KAAX,IAAoBvB,IAApB,EAA0B;AACxBoB,YAAAA,WAAW,CAACI,MAAZ,CAAmBD,KAAK,CAACE,IAAzB,EAA+BF,KAAK,CAACG,KAArC,EAA4CH,KAAK,CAACb,OAAlD;AACD;;AACDW,UAAAA,GAAG,GAAGD,WAAW,CAACO,aAAZ,EAAN;AACA5H,UAAAA,cAAc,CAAC,cAAD,CAAd,GAAkC,iCAAgCqH,WAAW,CAACQ,WAAZ,EAA0B,EAA5F;AACD,SATD,MASO;AACL,cAAI,OAAO5B,IAAP,KAAgB,QAApB,EAA8B;AAC5BqB,YAAAA,GAAG,GAAGQ,MAAM,CAACC,UAAP,CAAkB9B,IAAlB,CAAN;AACD,WAFD,MAEO;AACLqB,YAAAA,GAAG,GAAGrB,IAAI,CAAC3F,MAAX;AACD;;AACD+G,UAAAA,WAAW,GAAGS,MAAM,CAACE,QAAP,CAAgBX,WAAhB,IAA+BA,WAA/B,GAA6CS,MAAM,CAACG,IAAP,CAAYZ,WAAZ,CAA3D;AACD;;AACDrH,QAAAA,cAAc,CAAC,gBAAD,CAAd,GAAmCsH,GAAnC;AACD;;AACDtH,MAAAA,cAAc,CAAC,iBAAD,CAAd,GAAoC,eAApC;AACA,YAAMkI,aAAa,GAAG,IAAIpJ,OAAJ,CAAYiF,GAAZ,EAAiB4C,OAAjB,EAA0B;AAAEzC,QAAAA,MAAM,EAAExC,IAAI,CAACwC,MAAf;AAAuBrC,QAAAA,OAAO,EAAE7B;AAAhC,OAA1B,CAAtB;;AACA,UAAIkH,OAAJ,EAAa;AACX,YAAIxF,IAAI,CAAC6F,QAAT,EAAmB;AACjBF,UAAAA,WAAW,CAACtC,EAAZ,CAAe,OAAf,EAAwBE,GAAG,IAAI;AAC7BiD,YAAAA,aAAa,CAAC3G,IAAd,CAAmB,OAAnB,EAA4B0D,GAA5B;AACAiD,YAAAA,aAAa,CAAChD,KAAd;AACD,WAHD;AAIAgD,UAAAA,aAAa,CAACC,WAAd,CAA0Bd,WAA1B;AACD,SAND,MAMO;AACLa,UAAAA,aAAa,CAACE,KAAd,CAAoBf,WAApB;AACD;AACF;;AACD,aAAOa,aAAP;AACD,KArCD,CAqCE,OAAOG,CAAP,EAAU;AACV,YAAMC,kBAAkB,GAAG,IAAI9J,YAAJ,EAA3B;AACAkH,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM2C,kBAAkB,CAAC/G,IAAnB,CAAwB,OAAxB,EAAiC8G,CAAjC,CAAvB;;AACAC,MAAAA,kBAAkB,CAACC,GAAnB,GAAyB,MAAM,CAAE,CAAjC;;AACA,aAAOD,kBAAP;AACD;AACF;;AAED,MAAI3D,MAAJ;AAEA,QAAM6D,gBAAgB,GAAGhJ,MAAM,CAACY,IAAP,CAAYsB,IAAI,CAAC1B,cAAjB,EACtByC,MADsB,CACfxC,MAAM,IAAI,CAACb,aAAa,CAACoD,GAAd,CAAkBvC,MAAM,CAACE,WAAP,EAAlB,CADI,CAAzB;;AAGA,MAAIsG,WAAW,KAAK,CAACvH,aAAa,CAACsD,GAAd,CAAkByB,QAAlB,CAAD,IAAgCuE,gBAAgB,CAAClI,MAAjB,GAA0B,CAA1D,IAA+DO,UAAU,CAACqC,cAA/E,CAAf,EAA+G;AAC7GyB,IAAAA,MAAM,GAAG,IAAInG,YAAJ,EAAT;AAEA,UAAMiK,uBAAuB,GAAG,EAAhC;;AACA,SAAK,MAAMxI,MAAX,IAAqBD,cAArB,EAAqC;AACnC;AACA,YAAME,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;;AACA,UAAID,QAAQ,KAAK,QAAb,IAAyBA,QAAQ,KAAK,SAA1C,EAAqD;AACnDuI,QAAAA,uBAAuB,CAACxI,MAAD,CAAvB,GAAkCD,cAAc,CAACC,MAAD,CAAhD;AACD;AACF;;AAEDwI,IAAAA,uBAAuB,CAAC,+BAAD,CAAvB,GAA2D/G,IAAI,CAACwC,MAAhE;;AACA,QAAIsE,gBAAgB,CAAClI,MAAjB,GAA0B,CAA9B,EAAiC;AAC/BmI,MAAAA,uBAAuB,CAAC,gCAAD,CAAvB,GAA4DD,gBAAgB,CAACE,IAAjB,CAAsB,IAAtB,CAA5D;AACD;;AAEDD,IAAAA,uBAAuB,CAAC,YAAD,CAAvB,GAAwC/G,IAAI,CAAC6E,SAA7C;AAEA7E,IAAAA,IAAI,CAACiH,SAAL,GAAiB,IAAjB;AAEA,UAAM/B,kBAAkB,GAAGlF,IAAI,CAAC0E,SAAhC;AACA,UAAMwC,eAAe,GAAG,IAAI9J,OAAJ,CACtBiF,GADsB,EAEtB;AAAEmC,MAAAA,MAAF;AAAUW,MAAAA,eAAe,EAAE;AAA3B,KAFsB,EAGtB;AAAE3C,MAAAA,MAAM,EAAE,SAAV;AAAqBrC,MAAAA,OAAO,EAAE4G,uBAA9B;AAAuD7B,MAAAA;AAAvD,KAHsB,CAAxB;AAMAgC,IAAAA,eAAe,CAAC7D,EAAhB,CAAmB,UAAnB,EAA+B8D,IAAI,IAAI;AACrC;AACA,UAAIA,IAAI,CAACvE,UAAL,GAAkB,GAAlB,IAAyBuE,IAAI,CAACvE,UAAL,GAAkB,GAA/C,EAAoD;AAClDK,QAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB,IAAIJ,KAAJ,CAAU,yDAAyD0H,IAAI,CAACvE,UAAxE,CAArB;AACA;AACD,OALoC,CAMrC;;;AACA,UAAI,CAACnC,yBAAyB,CAACxB,GAAD,EAAMkI,IAAN,EAAYnH,IAAZ,EAAkBb,UAAlB,CAA9B,EAA6D;AAC3DkC,QAAAA,yBAAyB,CAACpC,GAAD,CAAzB;AACA;AACD,OAVoC,CAWrC;;;AACA,YAAMmI,UAAU,GAAG1B,SAAS,EAA5B;AACA0B,MAAAA,UAAU,CAAC/D,EAAX,CAAc,UAAd,EAA0B;AAAA,0CAAIgE,IAAJ;AAAIA,UAAAA,IAAJ;AAAA;;AAAA,eAAapE,MAAM,CAACpD,IAAP,CAAY,UAAZ,EAAwB,GAAGwH,IAA3B,CAAb;AAAA,OAA1B;AACAD,MAAAA,UAAU,CAAC/D,EAAX,CAAc,MAAd,EAAsBC,KAAK,IAAIL,MAAM,CAACpD,IAAP,CAAY,MAAZ,EAAoByD,KAApB,CAA/B;AACA8D,MAAAA,UAAU,CAAC/D,EAAX,CAAc,KAAd,EAAqB,MAAMJ,MAAM,CAACpD,IAAP,CAAY,KAAZ,CAA3B;AACAuH,MAAAA,UAAU,CAAC/D,EAAX,CAAc,OAAd,EAAuB,MAAMJ,MAAM,CAACpD,IAAP,CAAY,OAAZ,CAA7B;AACAuH,MAAAA,UAAU,CAAC/D,EAAX,CAAc,SAAd,EAAyBK,GAAG,IAAI;AAC9BT,QAAAA,MAAM,CAAC9C,OAAP,GAAiBiH,UAAU,CAACjH,OAA5B;AACA8C,QAAAA,MAAM,CAACpD,IAAP,CAAY,SAAZ,EAAuB6D,GAAvB;AACD,OAHD;AAIA0D,MAAAA,UAAU,CAAC/D,EAAX,CAAc,UAAd,EAA0B,YAAa;AAAA,2CAATgE,IAAS;AAATA,UAAAA,IAAS;AAAA;;AACrCpE,QAAAA,MAAM,CAACpD,IAAP,CAAY,UAAZ,EAAwB,GAAGwH,IAA3B;AACD,OAFD;AAGAD,MAAAA,UAAU,CAAC/D,EAAX,CAAc,OAAd,EAAuBE,GAAG,IAAI;AAC5BN,QAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB;AACD,OAFD;;AAGAN,MAAAA,MAAM,CAACO,KAAP,GAAe,MAAM;AACnB4D,QAAAA,UAAU,CAAC5D,KAAX;AACD,OAFD;;AAGA8D,MAAAA,YAAY,CAAC,MAAMF,UAAU,CAACP,GAAX,EAAP,CAAZ;AACD,KA/BD;AAiCAK,IAAAA,eAAe,CAAC7D,EAAhB,CAAmB,OAAnB,EAA4BE,GAAG,IAAI;AACjCN,MAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB;AACD,KAFD;;AAIAN,IAAAA,MAAM,CAACO,KAAP,GAAe,MAAM;AACnB0D,MAAAA,eAAe,CAAC1D,KAAhB;AACD,KAFD;;AAGA8D,IAAAA,YAAY,CAAC,MAAMJ,eAAe,CAACL,GAAhB,EAAP,CAAZ;AACD,GArED,MAqEO;AACL5D,IAAAA,MAAM,GAAGyC,SAAS,EAAlB;AACA4B,IAAAA,YAAY,CAAC,MAAMrE,MAAM,CAAC4D,GAAP,EAAP,CAAZ;AACD;;AAED,MAAInE,cAAJ,EAAoB;AAClB,UAAMgB,GAAG,GAAG;AACVF,MAAAA,KAAK,GAAG;AACNrE,QAAAA,UAAU,CAACwE,UAAX,GAAwB,IAAxB;AACA1E,QAAAA,GAAG,CAACuE,KAAJ;AACD;;AAJS,KAAZ;AAMAd,IAAAA,cAAc,CAACkB,GAAf,CAAmBF,GAAnB;AACA,UAAMG,KAAK,GAAGnB,cAAc,CAACoB,MAAf,CAAsBC,IAAtB,CAA2BrB,cAA3B,EAA2CgB,GAA3C,CAAd;AACAT,IAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,IAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,IAAAA,MAAM,CAACI,EAAP,CAAU,KAAV,EAAiBQ,KAAjB;AACD;;AACD,SAAOZ,MAAP;AACD;;AAEDpF,OAAO,CAACN,yBAAR,GAAoCA,yBAApC;AACAM,OAAO,CAACH,aAAR,GAAwBA,aAAxB;AACAG,OAAO,CAACF,gBAAR,GAA2BA,gBAA3B;AACAE,OAAO,CAACQ,gBAAR,GAA2BA,gBAA3B;AACAR,OAAO,CAACiB,mBAAR,GAA8BA,mBAA9B;AACAjB,OAAO,CAACmB,aAAR,GAAwBA,aAAxB;AACAnB,OAAO,CAACiC,gBAAR,GAA2BA,gBAA3B;AACAjC,OAAO,CAACwB,iBAAR,GAA4BA,iBAA5B;AACAxB,OAAO,CAACwD,yBAAR,GAAoCA,yBAApC;AACAxD,OAAO,CAACsE,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst { EventEmitter } = require(\"events\");\nconst { URL } = require(\"whatwg-url\");\nconst parseDataURL = require(\"data-urls\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst agentFactory = require(\"../helpers/agent-factory\");\nconst Request = require(\"../helpers/http-request\");\nconst FormData = require(\"form-data\");\nconst { fireAnEvent } = require(\"../helpers/events\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\n  \"access-control-expose-headers\",\n  \"access-control-allow-headers\",\n  \"access-control-allow-credentials\",\n  \"access-control-allow-origin\"\n]);\n\nconst READY_STATES = exports.READY_STATES = Object.freeze({\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n});\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr.properties.error;\n  requestErrorSteps(xhr, \"error\", DOMException.create(xhr._globalObject, [errMessage, \"NetworkError\"]));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = acah.has(\"*\") ?\n  [] :\n  Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const { flag, properties, upload } = xhr;\n\n  xhr.readyState = READY_STATES.DONE;\n  properties.send = false;\n\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n      fireAnEvent(\"loadend\", upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const { properties } = xhr;\n\n  properties.responseBuffer =\n    properties.responseCache =\n    properties.responseTextCache =\n    properties.responseXMLCache = null;\n\n  properties.responseHeaders = {};\n  xhr.status = 0;\n  xhr.statusText = \"\";\n}\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nfunction createClient(xhr) {\n  const { flag, properties } = xhr;\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n\n  const { requestManager } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    const filePath = urlObj.pathname\n      .replace(/^file:\\/\\//, \"\")\n      .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n      .replace(/%20/g, \" \");\n\n    const client = new EventEmitter();\n\n    const readableStream = fs.createReadStream(filePath, { encoding: null });\n\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response, urlObj.href));\n\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n\n    const client = new EventEmitter();\n\n    let buffer;\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = { \"content-type\": contentType };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {\n      // do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response, urlObj.href);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n\n    return client;\n  }\n  const agents = agentFactory(flag.proxy, flag.strictSSL);\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = { rejectUnauthorized: flag.strictSSL, agents, followRedirects: true };\n  if (flag.auth) {\n    options.user = flag.auth.user || \"\";\n    options.pass = flag.auth.pass || \"\";\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.cookieJar = flag.cookieJar;\n  }\n\n  const { body } = flag;\n  const hasBody = body !== undefined &&\n                  body !== null &&\n                  body !== \"\" &&\n                  !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      let requestBody = body;\n      let len = 0;\n      if (hasBody) {\n        if (flag.formData) {\n          // TODO: implement https://html.spec.whatwg.org/#multipart-form-data\n          // directly instead of using an external library\n          requestBody = new FormData();\n          for (const entry of body) {\n            requestBody.append(entry.name, entry.value, entry.options);\n          }\n          len = requestBody.getLengthSync();\n          requestHeaders[\"Content-Type\"] = `multipart/form-data; boundary=${requestBody.getBoundary()}`;\n        } else {\n          if (typeof body === \"string\") {\n            len = Buffer.byteLength(body);\n          } else {\n            len = body.length;\n          }\n          requestBody = Buffer.isBuffer(requestBody) ? requestBody : Buffer.from(requestBody);\n        }\n        requestHeaders[\"Content-Length\"] = len;\n      }\n      requestHeaders[\"Accept-Encoding\"] = \"gzip, deflate\";\n      const requestClient = new Request(uri, options, { method: flag.method, headers: requestHeaders });\n      if (hasBody) {\n        if (flag.formData) {\n          requestBody.on(\"error\", err => {\n            requestClient.emit(\"error\", err);\n            requestClient.abort();\n          });\n          requestClient.pipeRequest(requestBody);\n        } else {\n          requestClient.write(requestBody);\n        }\n      }\n      return requestClient;\n    } catch (e) {\n      const eventEmitterclient = new EventEmitter();\n      process.nextTick(() => eventEmitterclient.emit(\"error\", e));\n      eventEmitterclient.end = () => {};\n      return eventEmitterclient;\n    }\n  }\n\n  let client;\n\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders)\n    .filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n\n    const preflightRequestHeaders = {};\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referer\n      const lcHeader = header.toLowerCase();\n      if (lcHeader === \"origin\" || lcHeader === \"referer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n\n    flag.preflight = true;\n\n    const rejectUnauthorized = flag.strictSSL;\n    const preflightClient = new Request(\n      uri,\n      { agents, followRedirects: false },\n      { method: \"OPTIONS\", headers: preflightRequestHeaders, rejectUnauthorized }\n    );\n\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      }\n      // don't send the real request if we aren't allowed to use the headers\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n      // Set request gzip option right before headers are set\n      const realClient = doRequest();\n      realClient.on(\"response\", (...args) => client.emit(\"response\", ...args));\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", (...args) => {\n        client.emit(\"redirect\", ...args);\n      });\n      realClient.on(\"error\", err => {\n        client.emit(\"error\", err);\n      });\n      client.abort = () => {\n        realClient.abort();\n      };\n      setImmediate(() => realClient.end());\n    });\n\n    preflightClient.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n    setImmediate(() => preflightClient.end());\n  } else {\n    client = doRequest();\n    setImmediate(() => client.end());\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;\n"]},"metadata":{},"sourceType":"script"}