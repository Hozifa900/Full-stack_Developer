{"ast":null,"code":"\"use strict\";\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst {\n  Writable\n} = require(\"stream\");\n\nconst zlib = require(\"zlib\");\n\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\nconst majorNodeVersion = Number.parseInt(ver[0]);\n\nfunction abortRequest(clientRequest) {\n  // clientRequest.destroy breaks the test suite for versions 10 and 12,\n  // hence the version check\n  if (majorNodeVersion > 13) {\n    clientRequest.destroy();\n  } else {\n    clientRequest.abort();\n  }\n\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", () => {});\n}\n\nmodule.exports = class Request extends Writable {\n  constructor(url, clientOptions, requestOptions) {\n    super();\n    Object.assign(this, clientOptions);\n    this.currentURL = url;\n    this._requestOptions = requestOptions;\n    this.headers = requestOptions.headers;\n    this._ended = false;\n    this._redirectCount = 0;\n    this._requestBodyBuffers = [];\n    this._bufferIndex = 0;\n\n    this._performRequest();\n  }\n\n  abort() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n    this.removeAllListeners();\n  }\n\n  pipeRequest(form) {\n    form.pipe(this._currentRequest);\n  }\n\n  write(data, encoding) {\n    if (data.length > 0) {\n      this._requestBodyBuffers.push({\n        data,\n        encoding\n      });\n\n      this._currentRequest.write(data, encoding);\n    }\n  }\n\n  end() {\n    this.emit(\"request\", this._currentRequest);\n    this._ended = true;\n\n    this._currentRequest.end();\n  }\n\n  setHeader(name, value) {\n    this.headers[name] = value;\n\n    this._currentRequest.setHeader(name, value);\n  }\n\n  removeHeader(name) {\n    delete this.headers[name];\n\n    this._currentRequest.removeHeader(name);\n  } // Without this method, the test send-redirect-infinite-sync will halt the test suite\n  // TODO: investigate this further and ideally remove\n\n\n  toJSON() {\n    const {\n      method,\n      headers\n    } = this._requestOptions;\n    return {\n      uri: new URL(this.currentURL),\n      method,\n      headers\n    };\n  }\n\n  _writeNext(error) {\n    if (this._currentRequest) {\n      if (error) {\n        this.emit(\"error\", error);\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\n\n        if (!this._currentRequest.writableEnded) {\n          this._currentRequest.write(buffer.data, buffer.encoding, this._writeNext.bind(this));\n        }\n      } else if (this._ended) {\n        this._currentRequest.end();\n      }\n    }\n  }\n\n  _performRequest() {\n    var _this = this;\n\n    const urlOptions = new URL(this.currentURL);\n    const scheme = urlOptions.protocol;\n    this._requestOptions.agent = this.agents[scheme.substring(0, scheme.length - 1)];\n    const {\n      request\n    } = scheme === \"https:\" ? https : http;\n    this._currentRequest = request(this.currentURL, this._requestOptions, response => {\n      this._processResponse(response);\n    });\n    let cookies;\n\n    if (this._redirectCount === 0) {\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\n    }\n\n    if (this.cookieJar) {\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n    }\n\n    if (cookies && cookies.length) {\n      if (this.originalCookieHeader) {\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n      } else {\n        this.setHeader(\"Cookie\", cookies);\n      }\n    }\n\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\n      this._currentRequest.on(event, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.emit(event, ...args);\n      });\n    }\n\n    if (this._isRedirect) {\n      this._bufferIndex = 0;\n\n      this._writeNext();\n    }\n  }\n\n  _processResponse(response) {\n    const cookies = response.headers[\"set-cookie\"];\n\n    if (this.cookieJar && Array.isArray(cookies)) {\n      try {\n        cookies.forEach(cookie => {\n          this.cookieJar.setCookieSync(cookie, this.currentURL, {\n            ignoreError: true\n          });\n        });\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n\n    const {\n      statusCode\n    } = response;\n    const {\n      location\n    } = response.headers; // In Node v15, aborting a message with remaining data causes an error to be thrown,\n    // hence the version check\n\n    const catchResErrors = err => {\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n        this.emit(\"error\", err);\n      }\n    };\n\n    response.on(\"error\", catchResErrors);\n    let redirectAddress = null;\n    let resendWithAuth = false;\n\n    if (typeof location === \"string\" && location.length && this.followRedirects && statusCode >= 300 && statusCode < 400) {\n      redirectAddress = location;\n    } else if (statusCode === 401 && /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") && this.user && this.user.length) {\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\n      resendWithAuth = true;\n    }\n\n    if (redirectAddress || resendWithAuth) {\n      if (++this._redirectCount > 21) {\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n        this.emit(\"error\", redirectError);\n        return;\n      }\n\n      abortRequest(this._currentRequest);\n      response.destroy();\n      this._isRedirect = true;\n\n      if ((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method)) {\n        this._requestOptions.method = \"GET\";\n        this._requestBodyBuffers = [];\n      }\n\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\n\n      if (!previousHostName) {\n        previousHostName = new URL(this.currentURL).hostname;\n      }\n\n      const previousURL = this.currentURL;\n\n      if (!resendWithAuth) {\n        const nextURL = redirectAddress.startsWith(\"https:\") ? new URL(redirectAddress) : new URL(redirectAddress, this.currentURL);\n\n        if (nextURL.hostname !== previousHostName) {\n          this._removeMatchingHeaders(/^authorization$/i);\n        }\n\n        this.currentURL = nextURL.toString();\n      }\n\n      this.headers.Referer = previousURL;\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\n\n      try {\n        this._performRequest();\n      } catch (cause) {\n        this.emit(\"error\", cause);\n      }\n    } else {\n      let pipeline = response;\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\n      const requestCompressed = typeof acceptEncoding === \"string\" && (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n\n      if (requestCompressed && this._requestOptions.method !== \"HEAD\" && statusCode >= 200 && statusCode !== 204 && statusCode !== 304) {\n        const zlibOptions = {\n          flush: zlib.constants.Z_SYNC_FLUSH,\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\n        };\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n\n        if (contentEncoding === \"gzip\") {\n          pipeline = zlib.createGunzip(zlibOptions);\n          response.pipe(pipeline);\n        } else if (contentEncoding === \"deflate\") {\n          pipeline = zlib.createInflate(zlibOptions);\n          response.pipe(pipeline);\n        }\n      }\n\n      pipeline.removeAllListeners(\"error\");\n      this.emit(\"response\", response, this.currentURL);\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\n      pipeline.on(\"error\", catchResErrors);\n      pipeline.on(\"close\", () => this.emit(\"close\"));\n      this._requestBodyBuffers = [];\n    }\n  }\n\n  getHeader(key, value) {\n    if (this._currentRequest) {\n      return this._currentRequest.getHeader(key, value);\n    }\n\n    return null;\n  }\n\n  _removeMatchingHeaders(regex) {\n    let lastValue;\n\n    for (const header in this.headers) {\n      if (regex.test(header)) {\n        lastValue = this.headers[header];\n        delete this.headers[header];\n      }\n    }\n\n    return lastValue;\n  }\n\n};","map":{"version":3,"sources":["/Applications/MAMP/htdocs/aljazira/node_modules/jsdom/lib/jsdom/living/helpers/http-request.js"],"names":["http","require","https","Writable","zlib","ver","process","version","replace","split","majorNodeVersion","Number","parseInt","abortRequest","clientRequest","destroy","abort","removeAllListeners","on","module","exports","Request","constructor","url","clientOptions","requestOptions","Object","assign","currentURL","_requestOptions","headers","_ended","_redirectCount","_requestBodyBuffers","_bufferIndex","_performRequest","_currentRequest","emit","pipeRequest","form","pipe","write","data","encoding","length","push","end","setHeader","name","value","removeHeader","toJSON","method","uri","URL","_writeNext","error","buffer","writableEnded","bind","urlOptions","scheme","protocol","agent","agents","substring","request","response","_processResponse","cookies","originalCookieHeader","getHeader","cookieJar","getCookieStringSync","event","args","_isRedirect","Array","isArray","forEach","cookie","setCookieSync","ignoreError","e","statusCode","location","catchResErrors","err","message","redirectAddress","resendWithAuth","followRedirects","test","user","auth","pass","redirectError","Error","code","previousHostName","_removeMatchingHeaders","hostname","previousURL","nextURL","startsWith","toString","Referer","cause","pipeline","acceptEncoding","requestCompressed","includes","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","contentEncoding","trim","toLowerCase","createGunzip","createInflate","bytes","once","key","regex","lastValue","header"],"mappings":"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","sourcesContent":["\"use strict\";\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst { Writable } = require(\"stream\");\nconst zlib = require(\"zlib\");\n\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\nconst majorNodeVersion = Number.parseInt(ver[0]);\n\nfunction abortRequest(clientRequest) {\n  // clientRequest.destroy breaks the test suite for versions 10 and 12,\n  // hence the version check\n  if (majorNodeVersion > 13) {\n    clientRequest.destroy();\n  } else {\n    clientRequest.abort();\n  }\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", () => {});\n}\n\nmodule.exports = class Request extends Writable {\n  constructor(url, clientOptions, requestOptions) {\n    super();\n    Object.assign(this, clientOptions);\n    this.currentURL = url;\n    this._requestOptions = requestOptions;\n    this.headers = requestOptions.headers;\n    this._ended = false;\n    this._redirectCount = 0;\n    this._requestBodyBuffers = [];\n    this._bufferIndex = 0;\n    this._performRequest();\n  }\n\n  abort() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n    this.removeAllListeners();\n  }\n\n  pipeRequest(form) {\n    form.pipe(this._currentRequest);\n  }\n\n  write(data, encoding) {\n    if (data.length > 0) {\n      this._requestBodyBuffers.push({ data, encoding });\n      this._currentRequest.write(data, encoding);\n    }\n  }\n\n  end() {\n    this.emit(\"request\", this._currentRequest);\n    this._ended = true;\n    this._currentRequest.end();\n  }\n\n  setHeader(name, value) {\n    this.headers[name] = value;\n    this._currentRequest.setHeader(name, value);\n  }\n\n  removeHeader(name) {\n    delete this.headers[name];\n    this._currentRequest.removeHeader(name);\n  }\n\n  // Without this method, the test send-redirect-infinite-sync will halt the test suite\n  // TODO: investigate this further and ideally remove\n  toJSON() {\n    const { method, headers } = this._requestOptions;\n    return { uri: new URL(this.currentURL), method, headers };\n  }\n\n  _writeNext(error) {\n    if (this._currentRequest) {\n      if (error) {\n        this.emit(\"error\", error);\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\n        if (!this._currentRequest.writableEnded) {\n          this._currentRequest.write(\n            buffer.data,\n            buffer.encoding,\n            this._writeNext.bind(this)\n          );\n        }\n      } else if (this._ended) {\n        this._currentRequest.end();\n      }\n    }\n  }\n\n  _performRequest() {\n    const urlOptions = new URL(this.currentURL);\n    const scheme = urlOptions.protocol;\n    this._requestOptions.agent = this.agents[scheme.substring(0, scheme.length - 1)];\n    const { request } = scheme === \"https:\" ? https : http;\n    this._currentRequest = request(this.currentURL, this._requestOptions, response => {\n      this._processResponse(response);\n    });\n\n    let cookies;\n    if (this._redirectCount === 0) {\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\n    }\n    if (this.cookieJar) {\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n    }\n    if (cookies && cookies.length) {\n      if (this.originalCookieHeader) {\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n      } else {\n        this.setHeader(\"Cookie\", cookies);\n      }\n    }\n\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\n      this._currentRequest.on(event, (...args) => {\n        this.emit(event, ...args);\n      });\n    }\n    if (this._isRedirect) {\n      this._bufferIndex = 0;\n      this._writeNext();\n    }\n  }\n\n  _processResponse(response) {\n    const cookies = response.headers[\"set-cookie\"];\n    if (this.cookieJar && Array.isArray(cookies)) {\n      try {\n        cookies.forEach(cookie => {\n          this.cookieJar.setCookieSync(cookie, this.currentURL, { ignoreError: true });\n        });\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n\n    const { statusCode } = response;\n    const { location } = response.headers;\n    // In Node v15, aborting a message with remaining data causes an error to be thrown,\n    // hence the version check\n    const catchResErrors = err => {\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n        this.emit(\"error\", err);\n      }\n    };\n    response.on(\"error\", catchResErrors);\n    let redirectAddress = null;\n    let resendWithAuth = false;\n    if (typeof location === \"string\" &&\n      location.length &&\n      this.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400) {\n      redirectAddress = location;\n    } else if (statusCode === 401 &&\n      /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") &&\n      (this.user && this.user.length)) {\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\n      resendWithAuth = true;\n    }\n    if (redirectAddress || resendWithAuth) {\n      if (++this._redirectCount > 21) {\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n        this.emit(\"error\", redirectError);\n        return;\n      }\n      abortRequest(this._currentRequest);\n      response.destroy();\n      this._isRedirect = true;\n      if (((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\") ||\n        (statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method))) {\n        this._requestOptions.method = \"GET\";\n        this._requestBodyBuffers = [];\n      }\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\n      if (!previousHostName) {\n        previousHostName = new URL(this.currentURL).hostname;\n      }\n      const previousURL = this.currentURL;\n      if (!resendWithAuth) {\n        const nextURL = redirectAddress.startsWith(\"https:\") ?\n          new URL(redirectAddress) :\n          new URL(redirectAddress, this.currentURL);\n        if (nextURL.hostname !== previousHostName) {\n          this._removeMatchingHeaders(/^authorization$/i);\n        }\n        this.currentURL = nextURL.toString();\n      }\n      this.headers.Referer = previousURL;\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\n      try {\n        this._performRequest();\n      } catch (cause) {\n        this.emit(\"error\", cause);\n      }\n    } else {\n      let pipeline = response;\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\n      const requestCompressed = typeof acceptEncoding === \"string\" &&\n        (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n      if (\n        requestCompressed &&\n        this._requestOptions.method !== \"HEAD\" &&\n        statusCode >= 200 &&\n        statusCode !== 204 &&\n        statusCode !== 304\n      ) {\n        const zlibOptions = {\n          flush: zlib.constants.Z_SYNC_FLUSH,\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\n        };\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n        if (contentEncoding === \"gzip\") {\n          pipeline = zlib.createGunzip(zlibOptions);\n          response.pipe(pipeline);\n        } else if (contentEncoding === \"deflate\") {\n          pipeline = zlib.createInflate(zlibOptions);\n          response.pipe(pipeline);\n        }\n      }\n      pipeline.removeAllListeners(\"error\");\n      this.emit(\"response\", response, this.currentURL);\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\n      pipeline.on(\"error\", catchResErrors);\n      pipeline.on(\"close\", () => this.emit(\"close\"));\n      this._requestBodyBuffers = [];\n    }\n  }\n\n  getHeader(key, value) {\n    if (this._currentRequest) {\n      return this._currentRequest.getHeader(key, value);\n    }\n    return null;\n  }\n\n  _removeMatchingHeaders(regex) {\n    let lastValue;\n    for (const header in this.headers) {\n      if (regex.test(header)) {\n        lastValue = this.headers[header];\n        delete this.headers[header];\n      }\n    }\n    return lastValue;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}