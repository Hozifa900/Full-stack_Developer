{"ast":null,"code":"\"use strict\";\n\nconst {\n  hasWeakRefs\n} = require(\"../../utils\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst {\n  filter,\n  FILTER_ACCEPT\n} = require(\"./helpers\");\n\nexports.implementation = class NodeIteratorImpl {\n  constructor(globalObject, args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true; // This is used to deactivate the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n\n    if (!hasWeakRefs) {\n      this._working = true;\n    }\n\n    this._globalObject = globalObject;\n  }\n\n  get referenceNode() {\n    this._throwIfNotWorking();\n\n    return this._referenceNode;\n  }\n\n  get pointerBeforeReferenceNode() {\n    this._throwIfNotWorking();\n\n    return this._pointerBeforeReferenceNode;\n  }\n\n  nextNode() {\n    this._throwIfNotWorking();\n\n    return this._traverse(\"next\");\n  }\n\n  previousNode() {\n    this._throwIfNotWorking();\n\n    return this._traverse(\"previous\");\n  }\n\n  detach() {// Intentionally do nothing, per spec.\n  } // Called by Documents.\n\n\n  _preRemovingSteps(toBeRemovedNode) {\n    // Second clause is https://github.com/whatwg/dom/issues/496\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n      return;\n    }\n\n    if (this._pointerBeforeReferenceNode) {\n      let next = null;\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, {\n        skipChildren: true\n      });\n\n      while (candidateForNext !== null) {\n        if (this.root.contains(candidateForNext)) {\n          next = candidateForNext;\n          break;\n        }\n\n        candidateForNext = domSymbolTree.following(candidateForNext, {\n          skipChildren: true\n        });\n      }\n\n      if (next !== null) {\n        this._referenceNode = next;\n        return;\n      }\n\n      this._pointerBeforeReferenceNode = false;\n    }\n\n    const {\n      previousSibling\n    } = toBeRemovedNode;\n    this._referenceNode = previousSibling === null ? toBeRemovedNode.parentNode : domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n  } // Only called by getters and methods that are affected by the pre-removing steps\n\n\n  _throwIfNotWorking() {\n    if (!hasWeakRefs && !this._working) {\n      throw Error(`This NodeIterator is no longer working. More than 10 iterators are being used concurrently. ` + `Using more than 10 node iterators requires WeakRef support.`);\n    }\n  }\n\n  _traverse(direction) {\n    let node = this._referenceNode;\n    let beforeNode = this._pointerBeforeReferenceNode;\n\n    while (true) {\n      if (direction === \"next\") {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, {\n            root: this.root\n          });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else if (direction === \"previous\") {\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, {\n            root: this.root\n          });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n\n      const result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        break;\n      }\n    }\n\n    this._referenceNode = node;\n    this._pointerBeforeReferenceNode = beforeNode;\n    return node;\n  }\n\n};","map":{"version":3,"sources":["/Applications/MAMP/htdocs/aljazira/node_modules/jsdom/lib/jsdom/living/traversal/NodeIterator-impl.js"],"names":["hasWeakRefs","require","domSymbolTree","filter","FILTER_ACCEPT","exports","implementation","NodeIteratorImpl","constructor","globalObject","args","privateData","_active","root","whatToShow","_referenceNode","_pointerBeforeReferenceNode","_working","_globalObject","referenceNode","_throwIfNotWorking","pointerBeforeReferenceNode","nextNode","_traverse","previousNode","detach","_preRemovingSteps","toBeRemovedNode","contains","next","candidateForNext","following","skipChildren","previousSibling","parentNode","lastInclusiveDescendant","Error","direction","node","beforeNode","preceding","result"],"mappings":"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","sourcesContent":["\"use strict\";\nconst { hasWeakRefs } = require(\"../../utils\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { filter, FILTER_ACCEPT } = require(\"./helpers\");\n\nexports.implementation = class NodeIteratorImpl {\n  constructor(globalObject, args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true;\n\n    // This is used to deactivate the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n    if (!hasWeakRefs) {\n      this._working = true;\n    }\n\n    this._globalObject = globalObject;\n  }\n\n  get referenceNode() {\n    this._throwIfNotWorking();\n    return this._referenceNode;\n  }\n\n  get pointerBeforeReferenceNode() {\n    this._throwIfNotWorking();\n    return this._pointerBeforeReferenceNode;\n  }\n\n  nextNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"next\");\n  }\n\n  previousNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"previous\");\n  }\n\n  detach() {\n    // Intentionally do nothing, per spec.\n  }\n\n  // Called by Documents.\n  _preRemovingSteps(toBeRemovedNode) {\n    // Second clause is https://github.com/whatwg/dom/issues/496\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n      return;\n    }\n\n    if (this._pointerBeforeReferenceNode) {\n      let next = null;\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, { skipChildren: true });\n      while (candidateForNext !== null) {\n        if (this.root.contains(candidateForNext)) {\n          next = candidateForNext;\n          break;\n        }\n        candidateForNext = domSymbolTree.following(candidateForNext, { skipChildren: true });\n      }\n\n      if (next !== null) {\n        this._referenceNode = next;\n        return;\n      }\n\n      this._pointerBeforeReferenceNode = false;\n    }\n\n    const { previousSibling } = toBeRemovedNode;\n    this._referenceNode = previousSibling === null ?\n                          toBeRemovedNode.parentNode :\n                          domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n  }\n\n  // Only called by getters and methods that are affected by the pre-removing steps\n  _throwIfNotWorking() {\n    if (!hasWeakRefs && !this._working) {\n      throw Error(`This NodeIterator is no longer working. More than 10 iterators are being used concurrently. ` +\n        `Using more than 10 node iterators requires WeakRef support.`);\n    }\n  }\n\n  _traverse(direction) {\n    let node = this._referenceNode;\n    let beforeNode = this._pointerBeforeReferenceNode;\n\n    while (true) {\n      if (direction === \"next\") {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else if (direction === \"previous\") {\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n\n      const result = filter(this, node);\n      if (result === FILTER_ACCEPT) {\n        break;\n      }\n    }\n\n    this._referenceNode = node;\n    this._pointerBeforeReferenceNode = beforeNode;\n    return node;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}