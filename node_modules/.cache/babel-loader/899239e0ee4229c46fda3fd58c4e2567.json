{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst {\n  fileURLToPath\n} = require(\"url\");\n\nconst {\n  parseURL\n} = require(\"whatwg-url\");\n\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\n\nconst packageVersion = require(\"../../../../package.json\").version;\n\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\n\nconst Request = require(\"../../living/helpers/http-request\");\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\nmodule.exports = class ResourceLoader {\n  constructor() {\n    let {\n      strictSSL = true,\n      proxy = undefined,\n      userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` + `(KHTML, like Gecko) jsdom/${packageVersion}`\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\n    });\n\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n\n    return promise;\n  }\n\n  _readFile(filePath) {\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n    // Creating a promise for two reason:\n    //   1. fetch always return a promise.\n    //   2. We need to add an abort handler.\n\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n      abort = reject;\n      readableStream.on(\"error\", reject);\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n\n    return promise;\n  }\n\n  fetch(urlString) {\n    let {\n      accept,\n      cookieJar,\n      referrer\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const url = parseURL(urlString);\n\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n\n    switch (url.scheme) {\n      case \"data\":\n        {\n          return this._readDataURL(url);\n        }\n\n      case \"http\":\n      case \"https\":\n        {\n          const agents = agentFactory(this._proxy, this._strictSSL);\n          const headers = {\n            \"User-Agent\": this._userAgent,\n            \"Accept-Language\": \"en\",\n            \"Accept-Encoding\": \"gzip\",\n            \"Accept\": accept || \"*/*\"\n          };\n\n          if (referrer && !IS_BROWSER) {\n            headers.Referer = referrer;\n          }\n\n          const requestClient = new Request(urlString, {\n            followRedirects: true,\n            cookieJar,\n            agents\n          }, {\n            headers\n          });\n          const promise = new Promise((resolve, reject) => {\n            const accumulated = [];\n            requestClient.once(\"response\", res => {\n              promise.response = res;\n              const {\n                statusCode\n              } = res; // TODO This deviates from the spec when it comes to\n              // loading resources such as images\n\n              if (statusCode < 200 || statusCode > 299) {\n                requestClient.abort();\n                reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\n              }\n            });\n            requestClient.on(\"data\", chunk => {\n              accumulated.push(chunk);\n            });\n            requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\n            requestClient.on(\"error\", reject);\n          }); // The method fromURL in lib/api.js crashes without the following four\n          // properties defined on the Promise instance, causing the test suite to halt\n\n          requestClient.on(\"end\", () => {\n            promise.href = requestClient.currentURL;\n          });\n          promise.abort = requestClient.abort.bind(requestClient);\n\n          promise.getHeader = name => headers[name] || requestClient.getHeader(name);\n\n          requestClient.end();\n          return promise;\n        }\n\n      case \"file\":\n        {\n          try {\n            return this._readFile(fileURLToPath(urlString));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n\n      default:\n        {\n          return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n        }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Applications/MAMP/htdocs/aljazira/node_modules/jsdom/lib/jsdom/browser/resources/resource-loader.js"],"names":["fs","require","fileURLToPath","parseURL","dataURLFromRecord","fromURLRecord","packageVersion","version","agentFactory","Request","IS_BROWSER","Object","prototype","toString","call","process","module","exports","ResourceLoader","constructor","strictSSL","proxy","undefined","userAgent","platform","_strictSSL","_proxy","_userAgent","_readDataURL","urlRecord","dataURL","timeoutId","promise","Promise","resolve","setTimeout","body","abort","clearTimeout","_readFile","filePath","readableStream","reject","createReadStream","data","Buffer","alloc","on","chunk","concat","destroy","error","Error","isAbortError","fetch","urlString","accept","cookieJar","referrer","url","scheme","agents","headers","Referer","requestClient","followRedirects","accumulated","once","res","response","statusCode","push","href","currentURL","bind","getHeader","name","end","e"],"mappings":"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","sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst { fileURLToPath } = require(\"url\");\nconst { parseURL } = require(\"whatwg-url\");\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\nconst packageVersion = require(\"../../../../package.json\").version;\nconst agentFactory = require(\"../../living/helpers/agent-factory\");\nconst Request = require(\"../../living/helpers/http-request\");\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nmodule.exports = class ResourceLoader {\n  constructor({\n    strictSSL = true,\n    proxy = undefined,\n    userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` +\n                `(KHTML, like Gecko) jsdom/${packageVersion}`\n  } = {}) {\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\n    });\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n    return promise;\n  }\n\n  _readFile(filePath) {\n    let readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n\n    // Creating a promise for two reason:\n    //   1. fetch always return a promise.\n    //   2. We need to add an abort handler.\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n\n      abort = reject;\n\n      readableStream.on(\"error\", reject);\n\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n\n    return promise;\n  }\n\n  fetch(urlString, { accept, cookieJar, referrer } = {}) {\n    const url = parseURL(urlString);\n\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n\n    switch (url.scheme) {\n      case \"data\": {\n        return this._readDataURL(url);\n      }\n\n      case \"http\":\n      case \"https\": {\n        const agents = agentFactory(this._proxy, this._strictSSL);\n        const headers = {\n          \"User-Agent\": this._userAgent,\n          \"Accept-Language\": \"en\",\n          \"Accept-Encoding\": \"gzip\",\n          \"Accept\": accept || \"*/*\"\n        };\n        if (referrer && !IS_BROWSER) {\n          headers.Referer = referrer;\n        }\n        const requestClient = new Request(\n          urlString,\n          { followRedirects: true, cookieJar, agents },\n          { headers }\n        );\n        const promise = new Promise((resolve, reject) => {\n          const accumulated = [];\n          requestClient.once(\"response\", res => {\n            promise.response = res;\n            const { statusCode } = res;\n            // TODO This deviates from the spec when it comes to\n            // loading resources such as images\n            if (statusCode < 200 || statusCode > 299) {\n              requestClient.abort();\n              reject(new Error(`Resource was not loaded. Status: ${statusCode}`));\n            }\n          });\n          requestClient.on(\"data\", chunk => {\n            accumulated.push(chunk);\n          });\n          requestClient.on(\"end\", () => resolve(Buffer.concat(accumulated)));\n          requestClient.on(\"error\", reject);\n        });\n        // The method fromURL in lib/api.js crashes without the following four\n        // properties defined on the Promise instance, causing the test suite to halt\n        requestClient.on(\"end\", () => {\n          promise.href = requestClient.currentURL;\n        });\n        promise.abort = requestClient.abort.bind(requestClient);\n        promise.getHeader = name => headers[name] || requestClient.getHeader(name);\n        requestClient.end();\n        return promise;\n      }\n\n      case \"file\": {\n        try {\n          return this._readFile(fileURLToPath(urlString));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n\n      default: {\n        return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}